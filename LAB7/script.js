// Ми підписуємося на подію 'DOMContentLoaded' браузера.
// Пояснення: браузер генерує цю подію, коли повний DOM (структура HTML) завантажена й проаналізована,
// але до завантаження зовнішніх ресурсів (зображень, стилів) може ще бути час.
// Чому так робимо: щоб наш код створював і маніпулював DOM-елементами без помилок,
// гарантовано після того, як ті елементи можна додавати до document.body.
// Тобто — без цієї обгортки код міг би спробувати працювати ще до того, як document готовий. Це стрілкова функція (arrow function).
//Її ввели у JavaScript у стандарті ES6 (2015), щоб зробити код коротшим і читабельнішим.
document.addEventListener('DOMContentLoaded', () => {

  // === СТВОРЕННЯ ОСНОВНИХ ЕЛЕМЕНТІВ ===
  // Тепер ми послідовно створимо всі елементи інтерфейсу динамічно через JS.
  // Такий підхід робить HTML більш "чистим" і дозволяє програмно конфігурувати сторінку.

  // Створюємо блочний елемент <div>, який стане головним контейнером для всієї UI-частини.
  // Обґрунтування: контейнер дозволяє групувати елементи і застосувати до всього спільну стилізацію (flex, padding).
  const mainContainer = document.createElement('div');
  // Додаємо CSS-клас 'magic-container' — тим самим вказуємо, які стилі застосувати.
  // Клас пов'язує DOM-елемент з правилами з CSS-файлу.
  mainContainer.className = 'magic-container';

  // Створюємо додатковий <div> — wrapper для поля вводу питання.
  // Обґрунтування: окремий wrapper дозволяє вирівнювати поле вводу і керувати його розмірами незалежно від інших блоків.
  const questionWrapper = document.createElement('div');
  questionWrapper.className = 'question-wrapper';

  // Створюємо елемент input (поле для введення тексту).
  // Це текстове поле, де користувач може ввести своє питання.
  const questionInput = document.createElement('input');
  // Прив'язуємо до input CSS-клас для стилізації (ширина, padding, border тощо).
  questionInput.className = 'question-input';
  // Встановлюємо тип поля — 'text' означає звичайне текстове введення.
  // Це важливо, бо інші типи (number, email) обмежують ввід і змінюють поведінку клавіатури.
  questionInput.type = 'text';
  // Додаємо підказку (placeholder) — це текст, що відображається у полі до того, як користувач почне друкувати.
  // Пояснення: покращує UX — користувач розуміє, що саме вводити.
  questionInput.placeholder = 'Введіть своє питання (наприклад: "Чи знайду я своє кохання?")';
  // Додаємо input у wrapper — тепер поле вводу належить до контейнера, який ми створили раніше.
 // Метод appendChild() використовується для того, щоб вставити один HTML-елемент усередину іншого.
  questionWrapper.appendChild(questionInput);

  // Створюємо <div> для відображення повідомлень валідації (порожнє поле, занадто коротке питання тощо).
  // Такі повідомлення відображатимуться під полем вводу.
  const validationMessage = document.createElement('div');
  // Прив'язуємо стилі, щоб повідомлення було невеликим і займало ту ж ширину, що й поле.
  validationMessage.className = 'message-line';

  // Створюємо контейнер 'frame' для самої кристалевої кулі — це рамка, що додає фон, тіні й padding.
  // Обґрунтування: окрема рамка дозволяє зробити кулю адаптивною і відокремити її від кнопок/поля вводу.
  const ballFrame = document.createElement('div');
  ballFrame.className = 'ball-frame';

  // Створюємо елемент, що стане самою кулястою частиною (візуальна "кристалічна куля").
  // Цей елемент буде мати border-radius:50% у CSS, що робить його круглим.
  const crystalBall = document.createElement('div');
  crystalBall.className = 'crystal-ball';

  // Створюємо шар для світіння (glow) — окремий <div>, який розміщується під текстом відповіді.
  // Обґрунтування: окрема поверхня для glow дозволяє анімаційно вмикати/вимикати сяйво незалежно від тексту.
  const glowLayer = document.createElement('div');
  glowLayer.className = 'answer-glow';

  // Створюємо контейнер для тексту відповіді (label) — сюди ми підставлятимемо "Так", "Ні" і т.д.
  // Використання окремого елемента дозволяє контролювати opacity, transform і pointer-events для тексту.
  const answerLabel = document.createElement('div');
  answerLabel.className = 'answer-label';

  // Додаємо шар glowing (світіння) всередину кулі — ставимо його першим, бо він має бути під текстом.
  crystalBall.appendChild(glowLayer);
  // Додаємо елемент з текстом поверх glow (тому addChild викликається після).
  crystalBall.appendChild(answerLabel);
  // Вставляємо кришталеву кулю в рамку — таким чином рамка тепер містить сам круглий об'єкт.
  ballFrame.appendChild(crystalBall);

  // Створюємо блок для контролів (кнопок) під кулею.
  // Контрол-блок дозволяє розташувати кнопки в рядок або колонку через CSS flex.
  const controls = document.createElement('div');
  controls.className = 'controls';

  // Створюємо кнопку "Запитати кулю" — вона ініціює генерацію відповіді.
  const askButton = document.createElement('button');
  askButton.className = 'control-button';
  // Текст на кнопці: зрозумілий для користувача, локалізований українською.
  askButton.textContent = 'Запитати кулю';

  // Створюємо кнопку "Очистити" — для скидання поля вводу і відповіді.
  const clearButton = document.createElement('button');
  clearButton.className = 'control-button';
  clearButton.textContent = 'Очистити';

  // Додаємо кнопки у контейнер controls — тепер вони формально пов'язані разом.
  controls.appendChild(askButton);
  controls.appendChild(clearButton);

  // Збираємо весь інтерфейс: додаємо wrapper поля, повідомлення, рамку з кулею і контрол-блок у головний контейнер.
  mainContainer.appendChild(questionWrapper);
  mainContainer.appendChild(validationMessage);
  mainContainer.appendChild(ballFrame);
  mainContainer.appendChild(controls);

  // Додаємо головний контейнер у body документа — це робить UI видимим у браузері.
  // Важливо: цю операцію краще робити один раз, коли весь DOM готовий.
  document.body.appendChild(mainContainer);

  // === СПИСОК МОЖЛИВИХ ВІДПОВІДЕЙ ===
  // Масив стрічок, з якого будемо випадково вибирати відповідь.
  // Обґрунтування: збереження відповідей у масиві дає можливість легко додавати/змінювати варіанти,
  // і дозволяє використовувати Math.random() для псевдовипадкового вибору.
  const answers = [
    'Так', 'Ні', 'Можливо', 'Спробуй пізніше',
    'Без сумніву', 'Сумнівно', 'Звісно', 'Не думаю',
    'Є шанси', 'Зорі кажуть “так”'
  ];

  // === ФУНКЦІЯ ВІДОБРАЖЕННЯ ВІДПОВІДІ ===
  // Ця функція відповідає за відображення тексту у кулі та анімацію появи й згасання glow.
  function showAnswer(text) {
    // Встановлюємо текст відповіді всередині елементу answerLabel.
    // Як це працює: внутрішній текст елемента змінюється, і браузер перераховує layout і repaint, щоб показати новий текст.
    answerLabel.textContent = text;

    // Робимо текст повністю видимим, встановивши opacity = 1.
    // Чому opacity: зміна opacity анімується плавніше і не викликає переструктурування layout (покращує продуктивність).
    answerLabel.style.opacity = '1';

    // Вмикаємо світіння шару (glow), встановивши opacity = 1.
    // Glow — це окремий елемент з розмиттям; ми змінюємо тільки його прозорість, що дає плавний ефект.
    glowLayer.style.opacity = '1';

    // Використовуємо setTimeout для асинхронного зворотного ефекту: через 3000 мс починаємо згасання.
    // Пояснення: setTimeout створює таймер у браузері; після вказаного часу викликається передана функція.
    setTimeout(() => {
      // Через заданий інтервал зменшуємо прозорість тексту — це створює відчуття "згасання" відповіді.
      answerLabel.style.opacity = '0.3';
      // Гасимо glow — повертаємо його в невидимий стан.
      glowLayer.style.opacity = '0';
      // Примітка: плавність цих змін залежить від CSS transition, що визначено у стилях.
    }, 3000);
  }

  // === ФУНКЦІЯ ВІДОБРАЖЕННЯ ПОВІДОМЛЕНЬ ПРО ПОМИЛКУ ===
  // Викликається, коли валідація вхідних даних не пройдена.
  function showValidation(message) {
    // Встановлюємо текст повідомлення (наприклад: "Питання має бути довшим").
    validationMessage.textContent = message;
    // Встановлюємо колір тексту — у CSS це також можна робити класом, але тут швидко задаємо стиль інлайново.
    validationMessage.style.color = '#ffd1d1';
    // Пояснення: інлайн-стилі мають пріоритет над CSS-класами, тому це гарантовано змінить колір.
  }

  // === ФУНКЦІЯ ОЧИЩЕННЯ ПОВІДОМЛЕННЯ ===
  // Викликається перед генерацією відповіді або при очищенні форми.
  function clearValidation() {
    // Прибираємо текст повідомлення — це повертає простір під повідомлення у початковий стан.
    validationMessage.textContent = '';
    // За потреби тут можна було б також прибрати спеціальні CSS-класи (наприклад, для червоного бордера).
  }

  // === ОБРОБКА НАТИСКАННЯ КНОПКИ “Запитати кулю” ===
  // Додаємо слухача події click на askButton — це прив'язує поведінку при кліку.
  askButton.addEventListener('click', () => {
    // Зчитуємо вміст поля вводу, і одразу викликаємо trim(), щоб прибрати зайві пробіли з початку і кінця.
    // Чому trim: часто користувачі випадково вводять пробіли — trim дозволяє коректно проводити валідацію.
    const question = questionInput.value.trim();

    // Перевірка 1: якщо поле порожнє (після trim довжина = 0), повідомляємо користувача.
    if (question.length === 0) {
      // Показуємо повідомлення про помилку і повертаємося, щоб зупинити подальшу логіку.
      showValidation('Будь ласка, введіть питання.');
      return; // return зупиняє подальше виконання колбеку
    }

    // Перевірка 2: якщо питання занадто коротке (наприклад, менше 5 символів), також показуємо валідаційну підказку.
    // Чому така перевірка: короткі питання можуть бути випадковими або некоректними ("?","Hi" тощо).
    if (question.length < 5) {
      showValidation('Питання має бути довшим.');
      return;
    }

    // Якщо валідація пройдена — очищаємо будь-яке попереднє повідомлення про помилку.
    clearValidation();

    // Генеруємо випадкове число в діапазоні [0, answers.length).
    // Math.random() повертає float від 0 (включно) до 1 (не включно).
    // Помноживши на answers.length і застосувавши Math.floor, ми отримуємо цілий індекс.
    const randomAnswer = answers[Math.floor(Math.random() * answers.length)];
    // Викликаємо функцію showAnswer з обраним текстом — це оновить UI.
    showAnswer(randomAnswer);
  });

  // === ОБРОБКА КНОПКИ “Очистити” ===
  // При натисканні на clearButton ми повинні привести форму в початковий стан.
  clearButton.addEventListener('click', () => {
    // Очищаємо значення поля вводу — користувач бачить порожнє поле.
    questionInput.value = '';
    // Прибираємо текст відповіді з кулі.
    answerLabel.textContent = '';
    // Очищаємо повідомлення валідації, якщо воно було.
    clearValidation();
    // Примітка: ми не змінюємо тут опакітність glow чи answerLabel стилі безпосередньо,
    // бо при відсутності тексту вони не будуть заважати, але можна додати додаткове скидання стилів, якщо потрібно.
  });

  // === ОБРОБКА НАТИСКАННЯ КЛАВІШІ ENTER У ПОЛІ ВВОДУ ===
  // Додаємо слухача keydown на поле вводу, щоб дозволити користувачу натискати Enter для відправки питання.
  questionInput.addEventListener('keydown', (e) => {
    // Параметр e — об’єкт події, що містить інформацію про натиснуту клавішу.
    // Перевіряємо, чи натиснута клавіша — саме 'Enter' (рядок), а не інша.
    if (e.key === 'Enter') askButton.click(); // Викликаємо клік кнопки програмно — це запускає ту ж логіку, що й при фізичному натисканні.
    // Альтернатива: можна було б викликати ту саму функцію без симулювання click, але це простий і зрозумілий підхід.
  });
}); // Кінець прослуховування DOMContentLoaded